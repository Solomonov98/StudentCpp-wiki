* [Понятие массива](https://github.com/StriderAJR/StudentCpp/wiki/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B#%D0%9F%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)
* [Статический массив](https://github.com/StriderAJR/StudentCpp/wiki/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2)
* [Динамический массив](https://github.com/StriderAJR/StudentCpp/wiki/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2)
* [Строка как массив](https://github.com/StriderAJR/StudentCpp/wiki/%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B#%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B0-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2)

# Понятие массива
TODO
# Статический массив
TODO
# Динамический массив
TODO
# Строка как массив
> Строка - это массив символов, оканчивающийся символом конца строки (нулевым байтом `\0`, т.е. просто нулем)

А значит, как в любом массиве, переменная "строки" - это адрес на первый символ в строке. Остальные символы располагаются сразу за первым. 

Если в обычном массиве мы не знаем, где он заканчивается (для этого всегда нужно в отдельной переменной хранить кол-во элементов в массиве), то в строках для определения конца после последнего символа записывается нулевой байт, который и является признаком конца строки.

Например, для строки `Hello!` будет в памяти выделено 7 байт: по 1 байту для каждого символа = 6 байт + 1 нулевой байт, как символ конца строки. Т.е. в памяти последовательность байт выглядит так:

`72` `101` `108` `108` `111` `33` `0`

> В памяти все символы хранятся как код по таблице ASCII/Unicode/другая в зависимости от кодировки

Нулевой байт в конце строки позволяет при работе со строкой точно знать, где она заканчивается без дополнительного параметра.

Например,

```c++
char str0[7] = "qwerty";
cout << str0 << endl;
```
При создании строки после 6 "полезных" символов программа сама добавит еще 7 символ - нулевой байт, чтобы обозначить конец строки. При выводе строки на экран, будет выведены все байты, которые находятся до нулевого. Найдя нулевой байт в памяти, вывод остановится.

Думаете программа будет выводить ровно 6 или 7 байт, по кол-ву выведенной памяти? Давайте проверим.

```C++
char str0[7] = "qwerty";
cout << str0 << endl;
str0[6] = '!'; // Убираем нулевой байт из конца строки
cout << str0 << endl;
```
После создания строки и вывода ее на экран, мы "затерли" нулевой байт, который находился по индексу 6 (нумерация же с нуля в массиве).

И теперь вывод на экран строки `str0` будет примерно следующий: 
```
qwerty!МММММ??qxьх
```
Все что идет после символа `!` (вместо которого был нулевой байт) - это "мусор". Случайные цифры, которые были преобразованы в символы, потому что программы интерпретирует любые байты от адреса начала строки и до нулевого байта как символы.

Остановилась программа только тогда, когда нашла в памяти "случайный" ноль. В моем случае до этого момента вывелось 12 лишних символов.

По принципу "до нулевого байта" работают абсолютно все строковые ф-ции: `strcpy`, `strcmp`, `strcat` и другие.

Как вы видите в С++ работать со строками не так уж просто. Нужно всегда держать в голове состояние памяти и случайно его не испортить.

Чтобы облегчить эту задачи существует тип данных `string`, который по сути является оберткой вокруг обычного `char*`. У него есть функции получения длины, перегружены операторы для объединения строк, есть ф-ции поиска подстроки и много-много других удобных вещей.

Однако, как любая обертка, она не только упрощает вашу работу, но и не позволяет самостоятельно разобраться, как идет работа со строками.

> Пока вы самостоятельно не освоите и не будете чувствовать себя уверенно с типом данных `char*` *не используйте* тип данных string. Это позволит вам отточить навыки работы со строками, указателями и памятью.

## Статическая и динамическая строка
Также как и массив, строку можно создавать статическим путем и динамическим
### Статическая строка
Пример создания статической строки:

```c++
char str0[7] = "qwerty";
```

Создадим статическую строку и считаем в нее значение.

```c++
char str1[5];
cin >> str1;
cout << endl << str1 << endl;
```
Вроде бы, все хорошо. Однако даже в таком коде уже есть потенциальная ошибка.

Для строки `str1` было выделено всего 5 байт. Если ввод будет, допустим, `:)`, то будет все хорошо. Из буфера консоли в строку запишется 3 байта: `:` `)` `0`. Последний нулевой байт нужен как символ конца строки.

Поэтому после строчки `cout << str1;` выведется как и положено `:)`, хотя в строке и зарезервировано 5 байт (нулевой байт и все дела).

Однако, давайте попробуем считать с консоли, например, строку `abdce`. В ней же всего 5 символов. Как и положено. Ну ок, добавится 6 куда-нибудь после 5 наших. Все же должно быть хорошо? А вот фиг вам!

Будет ошибка: `Run-Time Check Failure #2 - Stack around the variable 'str1' was corrupted.`
По-русски это будет звучать примерно как (крайне не рекомендую пользоваться русской версией IDE, кстати): `Ошибка времени выполнения #2: Стек вокруг переменной str1 поврежден`.

Как так? Да очень просто. Мы выделили 5 байт под строку. Вместе с нулевым байтом у нас из буфера консоли пришло 6 байт. 6, нулевой байт, вышел за границы массива. С++, конечно, тупой, но состояние стека и кучи во время выполнения программы он все-таки отслеживает.

Во время выполнения выполнения программа ожидала, что состояние будет одно (например, что переменная str1 занимает всего 5 байт), а внезапно 6 байт после начала строки тоже оказался изменен! И программа естественно такая: Что за нафиг?! И выдала вам ошибку.

Поэтому считывать любые строковые переменные таким образом нельзя. Лучше делать это так:

```c++
char str1[5];
cin.getline(str1, 5);
cout << str1 << endl;
```
В этом случае даже если пользователь введет больше 4 символов (5й-то нам нужен под нулевой байт), например, `qwerty`, то все 6 символов запишутся в буфер консоли, однако команда `cin.getline(str1, 5);` из буфера извлечет и запишет в переменную `str1` только 5 байт (4 символа + нулевой байт).

И выведется на экран только: `qwer`. Ошибки уже не будет.

> Статические строки (их еще называют строки фиксированной, постоянной длины) подходят для хранения только значений определенной длины!

Ну хорошо, почему нельзя хранить больше, мы разобрались - больше просто не влезет, будет ошибка, но почему нельзя, скажем, в 10 байтах символов хранить всего 2 символа?

С++ позиционируется как язык с высокой оптимизацией не только скорости работы, но и использования памяти. Каждый байт при резервировании в памяти должен быть обоснован. Если вы создаете строку на 10 байтов, все эти 10 байт "заняты", компилятор не может их использовать. И если вы будете хранить в этих 10 байтах только 2 символа, то остальные 8 будут простаивать.

Хорошо 8 "потерянных" байт это не страшно. Однако привычка - страшная вещь. Не научившись сразу бережно относиться в памяти, вы рискуете всегда "жрать память" как не в себя. 

На эту тему даже есть анекдот:
```
Аккуратный стол, белая тарелочка на нем, на тарелочке оперативка. Сидит С++, аккуратно ножом отрезает кусочек и кушает. 
И ТУТ В СТОЛОВУЮ ВЛАМЫВАЕТСЯ СВИНЬЯ И СЖИРАЕТ ВСЮ ОПЕРАТИВКУ СРАЗУ - это Java. 
...С++ от испуга выплевывает откушенный кусочек и кричит: Segmentation fault!!!
```
Поэтому не нужно так. Храните в статических строках данные, которые не будут менять своей длины: номера телефонов, номера паспортов и т.д.

Для всех остальных случаев нужно использовать динамические строки.
### Динамическая строка
Динамические строки используются в случаях, когда вы *не знаете*, какой длины данные ждать от пользователя. В этом случае память под строку будет выделяться динамически в куче в процессе выполнения программы.

Алгоритм:
```
1. Считать строку в "большой" буфер
2. Определить, сколько в буфере "полезных" данных
3. Создать строку, выделив память ровно под "полезные" данные
4. Скопировать данные из буфера в строку
5. Уничтожить буфер, чтобы не занимал память
6. Профит
```
А теперь смысл:

Мы не знаем, сколько символов введет пользователь. Может быть, всего 10, а может быть и 100500. Но если он введет всего 10, мы не хотим иметь зарезервированную, но не используемую память. Если он введет 100500 символов, то мы не хотим случайно их потерять, потому что считываем из консоли только определенное кол-во символов.

Для этого и создается буфер с запасом памяти, чтобы точно хватило. И из консоли данные считываются в него. Если буфер у нас на 255 символов, а пользователь введет всего 10 символов, то нулевой байт даст нам знать, что "полезных" символов будет всего 10. 

Поэтому после считывания данных в буфер, мы можем узнать "реальную" длину буфера по нулевому байту и выделять память под требуемую строку ровно столько, сколько нужно. Скопировав затем данные из буфера в переменную, мы получаем компактную строку, в которой ровно столько байт, сколько было введено пользователем.

А теперь как это может выглядеть в коде:

```c++
char* buf = new char[255]; // Создаем буфер с "запасом", чтобы хватило
cin.getline(buf, 255); // Читаем данные в него
char* str2 = new char[strlen(buf)]; // Выделяем ровно столько памяти, сколько "полезных" символов в буфере
// strlen - ф-ция определения длины строки. Она считает символы только до нулевого байта
// Если пользователь ввел всего 10 символов, то strlen и вернет 10
strcpy(str2, buf); // Копируем реальную строку из буфера в переменную str2
delete[] buf; // Удаляем ненужный больше буфер
cout << str2;
```
Еще более хорошим тоном считается в программе выделить все это хозяйство в отдельную ф-цию, чтобы не писать каждый раз столько строк ради одного лишь считывания строки с экрана:

```c++
char* readString()
{
   char buf[255];
   cin.getline(buf, 255);
   char* str = new char[strlen(buf)]; 
   strcpy(str, buf);
   return str;
}
```
В данном случае нет необходимости создавать буфер, как динамическую строку, чтобы затем удалить ее вручную. Т.к. это ф-ция, а переменная `buf` - локальная переменная, она уничтожится сама, когда закончится блок кода, в котором она была объявлена, т.е. сама ф-ция.

Теперь считывать строку с экрана будет очень просто:

```c++
char* str3 = readString();
cout << str3 << endl;
```